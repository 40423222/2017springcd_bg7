var tipuesearch = {"pages":[{"text":"2017Spring 機械設計工程系協同產品設計實習 第七組協同倉儲 課程倉儲: https://github.com/40423222/2017springcd_bg7 課程投影片 https://40423222.github.io/2017springcd_bg7/ 課程網誌:： http://40423222.github.io/2017springcd_bg7/blog/ 組員倉儲： 40423202 40423221 40423222 40423228 40423245 40423248 40423251 組員網誌： 40423202 40423221 40423222 40423228 40423245 40423248 40423251 組員投影片： 40423202 40423221 40423222 40423228 40423245 40423248 40423251","url":"./pages/about/","tags":"misc","title":"About"},{"text":"第15W上課任務 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } 1. 任務一: 請以 W15 練習為網誌標題, 800x600 為畫布大小, 在畫布正中央畫一個半徑為 250 畫素, 壓力角 20, 齒數為 36 齒的漸開線正齒輪輪廓. from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"40px ScriptS\" ctx.fillText(\"40423222\",x-50,y) ctx.stroke() 2. 任務二: 完成後, 請在正齒輪中央寫上自己的學號, 並建立第二個 800x600 的畫布, 請畫出只有上半齒形的漸開線正齒輪輪廓 , 且該齒輪廓下方水平線, 連接兩端齒根圓點交的直線以紅色繪製, 且在齒輪下方以藍色字元寫上自己的學號. from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx-rp, midy, midx+rp, midy) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(-9,10): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear2'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 250 # 齒數 n = 36 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"40px ScriptS\" ctx.fillText(\"40423222\",x-50,y) ctx.stroke() 3. 任務三 請各學員在各自 github 倉儲中的 data/py 目錄中, 編寫一個可以採圓心座標, 節圓半徑, 齒數, 壓力角與定位角度作為輸入的齒輪程式函式, 交由組長從各組員的 submodule 設定中呼叫導入, 以便在各分組的網頁中完成一個畫出所有組員協同繪圖的齒輪減速組圖, 且各齒輪正中心必須寫上組員學號, 各組按照學號大小排序, 分別由最右邊齒數 16 齒開始囓合, 依序增加 2 齒, 當排至平面四齒囓合後, 第五位組員則以垂直方向向下囓合兩個齒輪後, 轉由右至左水平排列, 直至所有組員均各提供一個協同囓合用的齒輪為止. # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 16 # 第2齒輪齒數 n_g2 = 18 # 第3齒輪齒數 n_g3 = 20 # 第4齒輪齒數 n_g4 = 22 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3+n_g4) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 rp_g4 = m*n_g4/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 第4齒輪的圓心座標 x_g4 = x_g1 + rp_g1 + 2*rp_g2 + 2*rp_g3+rp_g4 y_g4 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#0000ff\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423222\",x_g1-30,y_g1) ctx.stroke() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423228\",x_g2-30,y_g2) ctx.stroke() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#ff0000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423245\",x_g3-30,y_g3) ctx.stroke() # 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第3齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g4, y_g4) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g2)*n_g2/n_g3+(math.pi+math.pi/n_g3)*n_g3/n_g4) # put it back ctx.translate(-x_g4, -y_g4) Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, \"green\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#008000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423248\",x_g4-30,y_g4) ctx.stroke() 4. 任務四 請依照上述規劃, 在 Onshape 完成相同齒輪組的囓合協同繪圖. 對圖片點擊左鍵 5. 任務五 各組員與組員請同時用 Youtube 與 vimeo, 紀錄上述各階段程式編寫與繪圖配置的 mp4 影片檔案, 標題為\"協同產品設計實習第十五週練習\" 但因為製作速度比拍影片快和輕鬆,也不怕網路不給利而Lag,再加上找起重點比看 影片簡單,所以我決定不製作影片,而來製作筆記 Code gear 開頭 主要是以下程式的名稱 可改變名稱,不引響程式內容 顯示齒數跟範圍 齒輪外齒顯示的範圍,顯示的齒數,由圓心垂直線向右長出 第行92 for j in range(n): n = 齒數 參考 for j in range(-9,10,+1): 顯示全部樣貌(因為36為全部的齒數) for j in range(36): 注意: 不能輸入負值 for j in range(-9): 可以輸入36(總齒數)以上的數量 for j in range(50): 控制左右方向長出的齒量 -3為向左長出3,3為向右長出3 for j in range(-3,3): 注意: 如果都輸入正數,會以右邊為顯示左邊為消除 因為左邊大於右邊,所以全消光 for j in range(7,3): 注意: 如果都輸入負數,會以左邊為顯示右邊為消除 顯示左7個齒,但會消去起點延伸的3個齒 for j in range(-7,-3): 注意: 不能左正右負 for j in range(7,-3): 疑問: 為何在最後要+1 for j in range(-9,10,+1): 設定 半徑/齒數/壓力角 第157~161行 r = 250 齒數 n = 36 壓力角 pa = 20 r = 半徑 n = 齒數 pa = 壓力角 疑問: r是代表齒輪的哪個半徑? 是 節圓半徑? 齒底半徑? 齒高半徑? ???? 齒輪名稱 第177行 這就是名稱 id=\"onegear2\" 這名稱要跟第301行canvas = doc['onegear2'] 名稱onegear2要對到 注意: 沒對到就不會顯示 注意: 要是名稱跟上方齒輪一樣會重疊 canvas = doc['onegear'] 控制紅線位置 第209行 self.create_line(midx-rp, midy, midx, midy) 有一到四格,順序為 x / y / x / y rp為長出,輸入一個rp,就會長出一個rp個長度,rp為一個值 正負決定方向 在midx +rp為向右長出,-rp為向左長出 在midy +rp為向下長出,-rp為向上長出 注意: 只能長出一條線,所以要是對midx and midy輸入rp 就會長出斜線 self.create_line( midx-rp, midy+rp, midx, midy) 說明: 以圓心出發,x向左一個rp,y向下一個rp,到達的這位置為終點 ,以圓心連到終點,完成此線 同時對兩個midx or midy輸入相同正負號的rp,是不會顯示紅線 self.create_line( midx, midy+rp, midx, midy+rp) 組合齒輪 在 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") 下方開始設定齒輪 壓力角 每個齒輪的壓力角都一樣 pa = 20 齒數 齒輪一到齒輪四的齒數 n_g1 = 16 n_g2 = 18 n_g3 = 20 n_g4 = 22 模數 模數定義: D(節圓直徑)/T(齒數),模數相同的齒輪才能憶起配合 說明: m 為模數, 根據畫布的寬度(800), 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3+n_g4) 節圓半徑 m(模數) T(齒數) = D(節圓直徑) 說明: 所以m(模數) T(齒數)/2(切半) = D/2(節圓半徑) rp_g1 = m n_g1/2 rp_g2 = m n_g2/2 rp_g3 = m n_g3/2 rp_g4 = m n_g4/2 圓心座標 先定義出齒一圓心 說明: 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 說明: 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width 0.1+rp_g1 說明: y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height 0.2+rp_g1 接著依序下去,注意: 每個圓心都要保持水平,都要是為y_g1 說明: 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 說明: 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2 rp_g2 + rp_g3 y_g3 = y_g1 說明: 第4齒輪的圓心座標 x_g4 = x_g1 + rp_g1 + 2 rp_g2 + 2*rp_g3+rp_g4 y_g4 = y_g1 組合 將一到四的齒輪組合,並簽上學號 說明: 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 說明: 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() 說明: translate to the origin of second gear ctx.translate(x_g1, y_g1) 說明: rotate to engage ctx.rotate(math.pi/2) 說明: put it back ctx.translate(-x_g1, -y_g1) 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#0000ff\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423222\",x_g1-30,y_g1) ctx.stroke() 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() translate to the origin of second gear ctx.translate(x_g2, y_g2) rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) 說明: put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#000000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423228\",x_g2-30,y_g2) ctx.stroke() 說明: 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() 說明: translate to the origin of second gear ctx.translate(x_g3, y_g3) 說明: rotate to engage 說明: math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 說明: 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 說明: 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 說明: -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 說明: (math.pi+math.pi/n_g2) n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, 說明: 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, 說明: 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2) n_g2/n_g3) 說明: put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#ff0000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423245\",x_g3-30,y_g3) ctx.stroke() 說明: 將第4齒輪逆時鐘轉 90 度之後, 再往回轉第3齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第3齒輪進行囓合 ctx.save() 說明: translate to the origin of second gear ctx.translate(x_g4, y_g4) 說明: rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g4+(math.pi+math.pi/n_g2) n_g2/n_g3+(math.pi+math.pi/n_g3) n_g3/n_g4) 說明: put it back ctx.translate(-x_g4, -y_g4) Spur(ctx).Gear(x_g4, y_g4, rp_g4, n_g4, pa, \"green\") ctx.restore() ctx.beginPath() ctx.fillStytle = \"#008000\" ctx.font = \"20px ScriptS\" ctx.fillText(\"40423248\",x_g4-30,y_g4) ctx.stroke() Oshape 在這我是使用正齒輪 齒輪的基本設定 模數都為(800*0.8)/(16+18+20+22) = 8.421 孔洞都為直徑20mm 壓力角都為20度 齒厚度為10mm 第一齒輪到第四齒輪的齒數為 n = 16 / 18 / 20 / 22 距離 第一齒輪到第四齒輪的節圓直徑為 D = 134.736 mm / 151.578 mm / 168.42 mm / 185.262 mm 節圓半徑用來計算齒輪跟齒輪的距離 例如: 134.736/2+151.578/2 = 齒輪一的圓心到齒輪二的圓心之距離 齒的接合 注意: 為了齒輪可以互相接合(不發生干涉) 所以要轉動 = 360(圓的角度)/(T(齒數)*2) = 一齒半的角度 速比 不同齒數的齒輪配合,就會產生速比 就像是第一齒輪被第二齒輪,速比就是18(齒數)/20(齒數) = 0.889 來寫個不同的模數,這樣就可以有... 做不到,因為節圓長度是用 畫布的寬來定義的 買滑鼠 齒輪圓心以下太佔空間了,便跟畫布高度跟圓心 關比指令來顯示筆記 參考對象45: https://40423245.github.io/2017springcd_hw/blog/2017spring-cd-W15.html","url":"./15W-Code gear.html","tags":"Course","title":"15W-Code gear"},{"text":"第15W上課任務 上課任務15W 個人還不會使用指令繪畫齒輪,所以使用Onshape來繪畫出齒輪 1. 繪畫出 半徑: 250 齒數: 36 壓力角: 20 的齒輪 點擊下方圖片 觀看齒輪 齒輪在Oshape 任務一 中展示 影片 協同產品設計實習第十五週練習-1 from 40423222 on Vimeo . 2. 繪畫出 半徑: 250 齒數: 36 壓力角: 20 的齒輪(只保留上半部) 點擊下方圖片 觀看齒輪 齒輪在Oshape 任務二 中展示 影片 協同產品設計實習第十五週練習-2 from 40423222 on Vimeo .","url":"./15W-Onshape gear.html","tags":"Course","title":"15W-Onshape gear"},{"text":"第15W上課任務 上課任務15W 個人還不會使用指令繪畫齒輪,所以使用Onshape來繪畫出齒輪 1. 繪畫出 半徑: 250 齒數: 36 壓力角: 20 的齒輪 點擊下方圖片 觀看齒輪 齒輪在Oshape 任務一 中展示 影片 協同產品設計實習第十五週練習-1 from 40423222 on Vimeo . 2. 繪畫出 半徑: 250 齒數: 36 壓力角: 20 的齒輪(只保留上半部) 點擊下方圖片 觀看齒輪 齒輪在Oshape 任務二 中展示 影片 協同產品設計實習第十五週練習-2 from 40423222 on Vimeo .","url":"./15W-gear.html","tags":"Course","title":"15W-gear"},{"text":"由48號完成的關於Onshape電子書的閱讀心得 1.小組協同閱讀兩本電子書翻譯並寫下心得 這裡為Onshape's Greatest Tech Tips– Volume 1.pdf 一.比較指令: 提供了可以檢視每次版本的不同,在設計時從原本的架構或是草圖,到後來隨著時間過去愈加愈多東西上去,就形成了許多的版次, Onshape的比較指令就是用來做現在的版本與過去的版本的對照,在版本和歷史的部分用下拉式選單裡面點Compare,就可以使用,可以和之前的任意 版本做外觀和特徵的差異 二.跟隨模式: 可以在Onshape線上即時的和你的夥伴修改和討論產品的外觀和細節,點右上方的social cue就可以開啟此功能,能夠即時的看到夥伴的螢幕狀況, 要離開時只要在圖像上的任意處點一下左鍵就可以離開,不用像以前的CAD軟體要協同作業還需要用電子郵件或傳送截圖,又或是版本不相容等許多的問題, Onshape的線上功能已經克服了這些問題,提供有效率又即時的線上協同工作環境 三.匯入/導入DXF檔案: DXF和DWG檔案是現在工業2D繪圖部分重要的標準,在Onshape裡面要導入DXF和DWG檔案可以點左上方的箭頭圖案,或是左下方的+圖案,裡面的選單也有導入的箭頭圖案, 點選導入後就可以瀏覽你想要導入的檔案,選擇你要的檔案來開啟,就可以導入至文件中,這時候可以做修改,也可以用此2D草圖來作3D建模,而要導出DXF檔的方式有兩 種,第一種是用右鍵點一下在繪圖介面上的繪圖標籤,就有導出,第二個是用右鍵點一下草圖的任意面,也有導出DXF的選項,之後就是一些選項調整,不用做繁雜的手續 來轉換檔案,只需要點個幾下就可以導入導出DXF或DWG檔案 四.捷徑工具列 Onshape的捷徑工具列讓使用指令變的更方便,要用工具列只要在畫面上按一下S,工具列就會出現在繪圖畫面上的游標旁邊,而捷徑工具列的設定方式可以在帳號設定 找到,打開後點偏好選項就可以開始自訂功能,要加入指令需要選取想要自訂的工具列,再選取草圖,零件,組裝,接著就可以加入想要的指令 五.加入評論 對於設計團隊來說在3D模型中加入評論是相當簡單而且是相當有效率的方式,可以在線上討論作品的問題或細節處理,不用寄送電子郵件來討論,在Onshape的頁面右上角 評論的圖示,可以把評論當成簡單的工具,能儲存和設計有關的註記,或是在線上即時和夥伴即時討論問題,也可以標記一些特定的特徵,不用互相傳截圖或電子郵件,是很 方便的功能 六.插入時的快照模式 快照模式可以更快建立組裝件,在插入零件時快照模式也能支援,只限定在自訂義連接配合時能用,用一個步驟就可以插入和配合零件,快照模式是從組裝工具列中調用或是按 鍵盤上的S鍵,點選要連接的兩個零件的配合點,然後點著和壓著左鍵並拖曳到目標的配合點,當你把零件拖曳到可能的配合點,Onshape就會顯示出圖像預覽,如果不想要這 個位置還可以再移到其他地方,可以省去一些時間,也能看到零件配合的預覽狀況,再慢慢作調整 七.綠色查驗(確認)以插入零件 在組合零件時的插入零件可以用綠色查驗(確認)來取代原有的零件,可以省去一開始要配對零件的時間,但零件仍需要固定,第一步要做的事是先插入第一個零件,在工具列 中點插入的指令,就會出現插入零件和組裝件的對話框,只要點選你想要的零件或多個零件就會看到該零件出現在頁面圖像中,但要注意一般在組裝視窗中插入的零件你會想 要零件是放在正中央的,這表示要取代第一個零件你不能在組裝件視窗中的空位處點左鍵,這樣零件會亂跑,反之,用左鍵點插入零件和組裝件的對話框中的綠色查驗(確認), 插入的零件就會自動取代原有的零件 八.多重瀏覽器標籤 你可以在Onshape頁面中開啟許多的網頁標籤(視窗),想開幾個都可以,因為Onshape是以瀏覽器來運行,是以瀏覽器的基礎來運作,所以可以在頁面中同時開啟許多網頁標籤(視窗), Onshape也支援多重螢幕顯示,可以把網頁標籤(視窗)移到其他螢幕上,能夠處理好幾個零件或組裝件,而當其中的一個零件被修改後在其他有這個零件的視窗(如組裝件)就會即時 變化,可以看到前後的差異,也可以在頁面標籤上點右鍵按在新瀏覽器標籤中開啟,這樣可以同步處理好幾個不同的零件或組裝程序,不用到處找檔案,很方便 九.捲動到此/捲動到尾端 當特徵清單很長的時候可以在特徵歷史中前後捲動,找你想要重新檢視或修改的特徵,但是當特徵清單很長又有幾個特徵需要多次修改時,就要用到捲動到此/捲動到尾端得兩個功能, 在特徵清單中找到想要修改的特徵時,再此特徵上點右鍵按Roll to here(捲動到此)的指令,系統就會把特徵清單尾端定在這裡,當修改完畢時就在特徵列上按Roll to end(捲動到尾端), 系統就會把位置定回原來的尾端特徵,這樣要修改某個特徵時就不用到處找,找到就可以直接固定,不用弄得很麻煩 十.再導入檔案時按著Shift來點選檔案 能夠省去手動一個一個點你想要的檔案的時間,可以點個兩三下就導入很多的檔案,當你想要從其他的CAD系統中導入檔案時就會用到這功能,要導入檔案時按左上方的箭頭圖案, 或是左下方的+圖案,點選導入後就可以瀏覽你想要導入的檔案,這時按著Shift點第一個檔案再點最後一個檔案,全部的檔案都會被選取,就可以同時導入多個檔案 2.閱讀寫心得: Designing Linkages in Context: https://www.onshape.com/cad-blog/designing-linkages-in-context FeatureScript: https://www.onshape.com/cad-blog/featurescript-its-so-easy-an-engineer-can-do-it","url":"./Onshape閱讀心得.html","tags":"Course","title":"Onshape閱讀心得"},{"text":"由45號完成的關於用指令繪畫漸開線齒輪 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") 單一正齒輪程式碼 window.onload=function(){ // 設定 data/py 為共用程式路徑 brython({debug:1, pythonpath:['./../data/py']}); } from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) canvas = doc['onegear'] ctx = canvas.getContext(\"2d\") x = (canvas.width)/2 y = (canvas.height)/2 r = 0.8*(canvas.height/2) # 齒數 n = 53 # 壓力角 pa = 20 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") 注意事項 1.當齒根半徑因為齒數增多後大於基圓半徑時, 漸開線從齒根圓長起 2.當基圓半徑大於齒根圓時, 漸開線從基圓長起 # 將 導入的 document 設為 doc 主要原因在於與舊程式碼相容 from browser import document as doc # 由於 Python3 與 Javascript 程式碼已經不再混用, 因此來自 Javascript 的變數, 必須居中透過 window 物件轉換 from browser import window import math # 主要用來取得畫布大小 canvas = doc[\"cango_gear\"] # 此程式採用 Cango Javascript 程式庫繪圖, 因此無需 ctx #ctx = canvas.getContext(\"2d\") cango = window.Cango.new # 針對變數的轉換, shapeDefs 在 Cango 中資料型別為變數, 可以透過 window 轉換 shapedefs = window.shapeDefs # 目前 Cango 結合 Animation 在 Brython 尚無法運作, 此刻只能繪製靜態圖形 # in CangoAnimation.js #interpolate1 = window.interpolate # Cobi 與 createGearTooth 都是 Cango Javascript 程式庫中的物件 cobj = window.Cobj.new creategeartooth = window.createGearTooth.new # 經由 Cango 轉換成 Brython 的 cango, 指定將圖畫在 id=\"cango_gear\" 的 canvas 上 cgo = cango(\"cango_gear\") ###################################### # 畫正齒輪輪廓 ##################################### # n 為齒數 n = 17 # pa 為壓力角 pa = 25 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 # Module = mm of pitch diameter per tooth m = 0.8*canvas.width/n # pr 為節圓半徑 pr = n*m/2 # gear Pitch radius # generate gear data = creategeartooth(m, n, pa) # Brython 程式中的 print 會將資料印在 Browser 的 console 區 #print(data) gearTooth = cobj(data, \"SHAPE\", { \"fillColor\":\"#ddd0dd\", \"border\": True, \"strokeColor\": \"#606060\" }) gearTooth.rotate(180/n) # rotate gear 1/2 tooth to mesh # 單齒的齒形資料經過旋轉後, 將資料複製到 gear 物件中 gear = gearTooth.dup() # gear 為單一齒的輪廓資料 #cgo.render(gearTooth) # 利用單齒輪廓旋轉, 產生整個正齒輪外形 for i in range(1, n): # 將 gearTooth 中的資料複製到 newTooth newTooth = gearTooth.dup() # 配合迴圈, newTooth 的齒形資料進行旋轉, 然後利用 appendPath 方法, 將資料併入 gear newTooth.rotate(360*i/n) # appendPath 為 Cango 程式庫中的方法, 第二個變數為 True, 表示要刪除最前頭的 Move to SVG Path 標註符號 gear.appendPath(newTooth, True) # trim move command = True # 建立軸孔 # add axle hole, hr 為 hole radius hr = 0.6*pr # diameter of gear shaft shaft = cobj(shapedefs.circle(hr), \"PATH\") shaft.revWinding() gear.appendPath(shaft) # retain the 'moveTo' command for shaft sub path cx = canvas.width/2 cy = canvas.height/2 gear.translate(cx, cy) # render 繪出靜態正齒輪輪廓 cgo.render(gear) 設法處理兩種正齒輪嚙合的協同繪圖 (17t-11t-13t): # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() 單一正齒輪程式碼 # 導入 browser 模組中的 document, 並設為 doc 變數 from browser import document as doc import math # deg 為角度轉為徑度的轉換因子 deg = math.pi/180. # 定義 Spur 類別 class Spur(object): def __init__(self, ctx): self.ctx = ctx def create_line(self, x1, y1, x2, y2, width=3, fill=\"red\"): self.ctx.beginPath() self.ctx.lineWidth = width self.ctx.moveTo(x1, y1) self.ctx.lineTo(x2, y2) self.ctx.strokeStyle = fill self.ctx.stroke() # # 定義一個繪正齒輪的繪圖函式 # midx 為齒輪圓心 x 座標 # midy 為齒輪圓心 y 座標 # rp 為節圓半徑, n 為齒數 # pa 為壓力角 (deg) # rot 為旋轉角 (deg) # 已經針對 n 大於等於 52 齒時的繪圖錯誤修正, 因為 base circle 與齒根圓大小必須進行判斷 def Gear(self, midx, midy, rp, n=20, pa=20, color=\"black\"): # 齒輪漸開線分成 15 線段繪製 imax = 15 # 在輸入的畫布上繪製直線, 由圓心到節圓 y 軸頂點畫一直線 self.create_line(midx, midy, midx, midy-rp) # 畫出 rp 圓, 畫圓函式尚未定義 #create_oval(midx-rp, midy-rp, midx+rp, midy+rp, width=2) # a 為模數 (代表公制中齒的大小), 模數為節圓直徑(稱為節徑)除以齒數 # 模數也就是齒冠大小 a=2*rp/n # d 為齒根大小, 為模數的 1.157 或 1.25倍, 這裡採 1.25 倍 d=2.5*rp/n # ra 為齒輪的外圍半徑 ra=rp+a # 畫出 ra 圓, 畫圓函式尚未定義 #create_oval(midx-ra, midy-ra, midx+ra, midy+ra, width=1) # rb 則為齒輪的基圓半徑 # 基圓為漸開線長齒之基準圓 rb=rp*math.cos(pa*deg) # 畫出 rb 圓 (基圓), 畫圓函式尚未定義 #create_oval(midx-rb, midy-rb, midx+rb, midy+rb, width=1) # rd 為齒根圓半徑 rd=rp-d # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd # 畫出 rd 圓 (齒根圓), 畫圓函式尚未定義 #create_oval(midx-rd, midy-rd, midx+rd, midy+rd, width=1) # dr 則為基圓到齒頂圓半徑分成 imax 段後的每段半徑增量大小 # 將圓弧分成 imax 段來繪製漸開線 # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: dr = (ra-rd)/imax else: dr=(ra-rb)/imax # tan(pa*deg)-pa*deg 為漸開線函數 sigma=math.pi/(2*n)+math.tan(pa*deg)-pa*deg for j in range(n): ang=-2.*j*math.pi/n+sigma ang2=2.*j*math.pi/n+sigma lxd=midx+rd*math.sin(ang2-2.*math.pi/n) lyd=midy-rd*math.cos(ang2-2.*math.pi/n) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(alpha-ang) ypt=r*math.cos(alpha-ang) xd=rd*math.sin(-ang) yd=rd*math.cos(-ang) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由左側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): lfx=midx+xpt lfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # the line from last end of dedendum point to the recent # end of dedendum point # lxd 為齒根圓上的左側 x 座標, lyd 則為 y 座標 # 下列為齒根圓上用來近似圓弧的直線 self.create_line((lxd),(lyd),(midx+xd),(midy-yd),fill=color) for i in range(imax+1): # 當 rd 大於 rb 時, 漸開線並非畫至 rb, 而是 rd if rd>rb: r=rd+i*dr else: r=rb+i*dr theta=math.sqrt((r*r)/(rb*rb)-1.) alpha=theta-math.atan(theta) xpt=r*math.sin(ang2-alpha) ypt=r*math.cos(ang2-alpha) xd=rd*math.sin(ang2) yd=rd*math.cos(ang2) # i=0 時, 繪線起點由齒根圓上的點, 作為起點 if(i==0): last_x = midx+xd last_y = midy-yd # 由右側齒根圓作為起點, 除第一點 (xd,yd) 齒根圓上的起點外, 其餘的 (xpt,ypt)則為漸開線上的分段點 self.create_line((midx+xpt),(midy-ypt),(last_x),(last_y),fill=color) # 最後一點, 則為齒頂圓 if(i==imax): rfx=midx+xpt rfy=midy-ypt last_x = midx+xpt last_y = midy-ypt # lfx 為齒頂圓上的左側 x 座標, lfy 則為 y 座標 # 下列為齒頂圓上用來近似圓弧的直線 self.create_line(lfx,lfy,rfx,rfy,fill=color) # 準備在 id=\"gear3\" 的 canvas 中繪圖 canvas = doc[\"gear3\"] ctx = canvas.getContext(\"2d\") # 模數決定齒的尺寸大小, 囓合齒輪組必須有相同的模數與壓力角 # 壓力角 pa 單位為角度 pa = 20 # 第1齒輪齒數 n_g1 = 17 # 第2齒輪齒數 n_g2 = 11 # 第3齒輪齒數 n_g3 = 13 # m 為模數, 根據畫布的寬度, 計算適合的模數大小 m = (0.8*canvas.width)/(n_g1+n_g2+n_g3) # 根據模數 m, 計算各齒輪的節圓半徑 rp_g1 = m*n_g1/2 rp_g2 = m*n_g2/2 rp_g3 = m*n_g3/2 #單一正齒輪繪圖呼叫格式 Spur(ctx).Gear(x, y, r, n, pa, \"blue\") # 開始繪製囓合齒輪輪廓 # 繪圖第1齒輪的圓心座標, 因為希望繪圖佔去 canvas.width 的 80%, 所以兩邊各預留 10% 距離 x_g1 = canvas.width*0.1+rp_g1 # y 方向繪圖區域上方預留 canvas.height 的 20% y_g1 = canvas.height*0.2+rp_g1 # 第2齒輪的圓心座標, 假設排列成水平, 表示各齒輪圓心 y 座標相同 x_g2 = x_g1 + rp_g1 + rp_g2 y_g2 = y_g1 # 第3齒輪的圓心座標 x_g3 = x_g1 + rp_g1 + 2*rp_g2 + rp_g3 y_g3 = y_g1 # 將第1齒輪順時鐘轉 90 度, 也就是 math.pi/2 # 使用 ctx.save() 與 ctx.restore() 以確保各齒輪以相對座標進行旋轉繪圖 ctx.save() # translate to the origin of second gear ctx.translate(x_g1, y_g1) # rotate to engage ctx.rotate(math.pi/2) # put it back ctx.translate(-x_g1, -y_g1) # 繪製第一個齒輪輪廓 Spur(ctx).Gear(x_g1, y_g1, rp_g1, n_g1, pa, \"blue\") ctx.restore() # 將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g2, y_g2) # rotate to engage ctx.rotate(-math.pi/2-math.pi/n_g2) # put it back ctx.translate(-x_g2, -y_g2) Spur(ctx).Gear(x_g2, y_g2, rp_g2, n_g2, pa, \"black\") ctx.restore() # 將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合 ctx.save() # translate to the origin of second gear ctx.translate(x_g3, y_g3) # rotate to engage # math.pi+math.pi/n_g2 為第2齒輪從順時鐘轉 90 度之後, 必須配合目前的標記線所作的齒輪 2 轉動角度, 要轉換到齒輪3 的轉動角度 # 必須乘上兩齒輪齒數的比例, 若齒輪2 大, 則齒輪3 會轉動較快 # 第1個 -math.pi/2 為將原先垂直的第3齒輪定位線逆時鐘旋轉 90 度 # -math.pi/n_g3 則是第3齒與第2齒定位線重合後, 必須再逆時鐘多轉一齒的轉角, 以便進行囓合 # (math.pi+math.pi/n_g2)*n_g2/n_g3 則是第2齒原定位線為順時鐘轉動 90 度, # 但是第2齒輪為了與第1齒輪囓合, 已經距離定位線, 多轉了 180 度, 再加上第2齒輪的一齒角度, 因為要帶動第3齒輪定位, # 這個修正角度必須要再配合第2齒與第3齒的轉速比加以轉換成第3齒輪的轉角, 因此乘上 n_g2/n_g3 ctx.rotate(-math.pi/2-math.pi/n_g3+(math.pi+math.pi/n_g2)*n_g2/n_g3) # put it back ctx.translate(-x_g3, -y_g3) Spur(ctx).Gear(x_g3, y_g3, rp_g3, n_g3, pa, \"red\") ctx.restore() 注意事項 1.第1齒輪順時鐘轉 90 度 2.將第2齒輪逆時鐘轉 90 度之後, 再多轉一齒, 以便與第1齒輪進行囓合 3.將第3齒輪逆時鐘轉 90 度之後, 再往回轉第2齒輪定位帶動轉角, 然後再逆時鐘多轉一齒, 以便與第2齒輪進行囓合","url":"./漸開線齒輪-指令.html","tags":"Course","title":"漸開線齒輪-指令"},{"text":"以下為協同產品設計實習的期末計畫 計畫流程 - (建立)2017/5/16 1. 討論要繪畫何種步行機構 我們原本是要製作四角步行者,但因為45號用V-rep檢驗出結構不穩定,而淘汰,最後決定繪畫 8連桿 的仿生獸 四腳步行者,結構不穩定 2017-05-12_21-45-50 from 40423245 on Vimeo . 仿生獸 仿生獸 from phymec on YouTube . 2. 用Onshape繪畫出仿生獸的初步構造 我複製45號繪畫的8連桿,來組裝出仿生獸,最後跟45號合力完成初步樣貌 用Onshape觀看仿生獸 組裝重點 仿生獸-組裝重點 from 40423222 on Vimeo . 初步完成 仿生獸-初步完成 from 40423222 on Vimeo . 3. 用V-rep模擬出在地板行走的影片 45號用V-rep模擬確認哪裡需要改良 用V-rep模擬仿生獸 2017-05-16_21-47-51 from 40423245 on Vimeo . 4. 製作出實體模型 因為3D列印的機會只有一次,所以我決定要製作出實體模型,下課到我房間集合,從集結材料到製作出成品,共花費的4小時.... 原先45號有先自己製作出紙製模型,但因為強度跟組裝,我不認同,所以才沒製作 之後我跟48號去準備材料,材料費由我來承擔,45號跟51號準備等要製作的尺寸圖,經過3小時多的時間,作後完成了....... 雖然因為軸繪卡點,還有無法合併,再加上累了,而放棄了繼續製作,但也因為有這次組裝的經驗,發現軸帶過細小(值徑: 3 mm),也發現軸要改成螺栓,並也將要重新設計仿生獸,不再是六隻腳,將會桿成四隻腳,並在中央設置齒輪箱 5. 用V-rep模擬出在地板行走的影片 經由45號不斷地修改加測試,仿生獸終於能在地上行走,雖然最後還是會出錯,但已經能看到幾秒行走的過程 2017-05-18_21-54-06 from 40423245 on Vimeo . 6. 改進第一代仿生獸 點擊這觀看第二代仿生獸 注意: 第二代仿生獸在下方標題的 error 內 Onshape-第二代仿生獸-行走影片 注意:Onshape只能顯現外表,無法顯現干涉 / 內應力 / 物體重量 等等.... -行走影片 from 40423222 on Vimeo . Onshape-第二代仿生獸-介紹 比起第一代仿生獸,新增了平台,來放置Arduino板 and Motor ..... -介紹 from 40423222 on Vimeo . 繪畫螺紋 軸原本要使用螺栓,但因為會阻礙到連桿,所以放棄這作法 Oshape繪畫螺紋 from 40423222 on Vimeo . 7. 改進第二代仿生獸 Onshape-第三代仿生獸-行走影片 注意:Onshape只能顯現外表,無法顯現干涉 / 內應力 / 物體重量 等等.... 因還有許多地方要改進,所以不拍攝影片 Onshape-第三代仿生獸-介紹 比起第二代仿生獸,更新了平台 / 連桿 / 軸,更輕更帥氣 -介紹 from 40423222 on Vimeo . 窩桿渦輪 點擊這觀看45號,所製作的Blog 40423245機械設計工程系 - 協同產品設計實習課程W14-在Onshape中繪製蝸桿蝸輪 from 40423245 on Vimeo . 8. 第三代仿生獸 點擊這觀看第三代仿生獸 介紹影片 第三代仿生獸介紹-30秒到3分有爆音 from 40423222 on Vimeo . 注意: 00:30到03:00影片有爆音 還未完成: 確認馬達規格 Onshape行走影片(有太多問題就放棄) 45號的V-rep模擬 工作分配 組長: 40423222 討論要繪畫何種步行機構: 跟組員互相討論 用Onshape繪畫出仿生獸的初步構造: 組裝出仿生獸 做出實際模型: 材料,打洞,組裝 改進第一代仿生獸: 組長負責 改進第二代仿生獸: 更新零件跟組裝 第三代仿生獸: 繪製見開線齒輪,組裝成形 組員: 40423245 討論要繪畫何種步行機構: 跟組員互相討論 用Onshape繪畫出仿生獸的初步構造: 繪畫出組裝零件 用V-rep模擬出在地板行走的影片: 45號製作 做出實際模型: 初版模型,標打洞記號,組裝 改進第二代仿生獸: 繪畫出窩桿渦輪 第三代仿生獸: 繪製Arduino固定架,組裝成形 組員: 40423248 討論要繪畫何種步行機構: 跟組員互相討論 做出實際模型: 材料,打洞,組裝 組員: 40423251 做出實際模型: 標打洞記號,組裝","url":"./期末計畫-行走機構.html","tags":"Course","title":"期末計畫-行走機構"},{"text":"以下為用Onshape繪畫漸開線齒輪,並組裝和模擬, 繪畫漸開線齒輪: 繪畫漸開線齒輪 from 40423222 on Vimeo . 個人筆記的一小部分: 例題二 設定 節圓直徑35 齒數10 所以 35/10 = 3.5模數 所以畫出節圓35 以節圓 向外畫3.5為齒高(因為模數為3.5) 向內畫3.8為齒底(要多0.3的空隙 這0.3要查表而知) 畫相切節圓的切線 在畫通過切線跟節圓的線 並跟切線夾20度 20度就是壓力角 以圓心畫圓相切這壓力線 這就是假想圓或稱基圓 壓力線在齒頂圓跟假想圓的長度為13.06 以這兩端點連向圓心 以壓力線為起點 假想圓長度 要等於 13.06 2 PI R/x = 13.06 R = 假想圓半徑 x = 要求y的值 = 7.9075 360/x = y y就是假想圓的角度 = 45.526615 這樣假想圓的就是14.295 以5等分來劃出漸開線 9.105323 每下一條件開線 都要小20%壓力線的長度 因為是5等分 所以每次都要小20% 把齒一到中上位置 角度是9 因為有10齒 360/20 = 18 18的一半 = 9 因為10齒+空的10齒 = 200 所以才要除20 組裝跟測試結果: Onshape漸開線齒輪 from 40423222 on Vimeo . 觀看零件: 點擊圖片 參考對象: https://www.youtube.com/watch?v=PXdk3sbK-ZM","url":"./漸開線齒輪-Onshape.html","tags":"Course","title":"漸開線齒輪-Onshape"},{"text":"想了解Arduino Uno板的實驗,請到40423222的個人網誌 有詳細的Arfuino說明 40423222的個人網誌","url":"./Arduino.html","tags":"Arduino","title":"Arduino"},{"text":"以下為協同產品設計實習 2017 Spring 期中考週的實習查驗題目 期中考任務 (一) Fossil Server 實習查驗 建立一台以 https 為連結協定的 Fossil Server (起始 Timeline 必須為期中考當天日期與時間為準), 並命名乙班第7組為 bg7 期中報告,為 server 標題, 每一組員以學號為帳號, 各組員分別在 Wiki 中以 [學號] 期中學習心得\"命名 (例如: 40423222 期中學習心得) 為 Wiki 頁面標題, 概述上課至今的心得與自評成績. 完成後, 請報上各組 Serve 的 ip 位址進行查驗. (二) 四連桿機構協同 Trace Point 查驗 可來參考 電腦輔助設計實習第十週上課內容 , 在各組網誌中, 以子模組 (Github Submodule) 的設定, 擷取各組員倉儲中的 T 點軌跡座標檔 (請以 midterm1.csv, midterm2.csv .... 依序命名) 後進行網際協同繪圖. 各組組員請依學號遞增排序, 排序第1者負責分析 Length=50 的 T 點軌跡圖, 其餘組員則依序將 Length -5, 分別在各組網誌中列出所有組員所完成的四連桿 T 點運動軌跡圖. (例如: 第2位組員負責 Length=45 的四連桿分析, 第3位則負責 Length=40 ....) 例如: (長 30 mm 的連桿為馬達輸入桿, Trace Point 為 T 點) 40423222協同產品設計實習W9-fourbar link 50 點分析 from 40423222 on Vimeo . window.onload=function(){ brython(1); } from browser import document as doc from browser import html import math # 準備繪圖畫布 canvas = doc[\"fourbar\"] container1 = doc['container1'] ctx = canvas.getContext(\"2d\") fourbar_data = open(\"./../data/cadpa_w10_4bar.csv\").read() fourbar_list = fourbar_data.splitlines() #container1 <= fourbar_list[0] # 以下可以利用 ctx 物件進行畫圖 # 先畫一條直線 ctx.beginPath() # 設定線的寬度為 1 個單位 ctx.lineWidth = 1 # 利用 transform 將 y 座標反轉, 且 offset canvas.height # (X scale, X skew, Y skew, Y scale, X offset, Y offset) # 配合圖形位置進行座標轉換 ctx.transform(1, 0, 0, -1, canvas.width/2+250, canvas.height/2+100) # 畫出 x 與 y 座標線 # 各座標值放大 8 倍 ratio = 8 ctx.moveTo(0, 0) ctx.lineTo(-30*ratio, 0) start_point = fourbar_list[0].split(\",\") ctx.moveTo(float(start_point[0])*ratio, float(start_point[1])*ratio) count = 0 for data in fourbar_list[1:]: point = data.split(\",\") #count = count + 1 #container1 <= str(count) + \":\" + point[0] + \",\" + point[1] #container1 <= html.BR() ctx.lineTo(float(point[0])*ratio, float(point[1])*ratio) # 設定顏色為藍色, 也可以使用 \"rgb(0, 0, 255)\" 字串設定顏色值 ctx.strokeStyle = \"blue\" # 實際執行畫線 ctx.stroke() ctx.closePath() (三) Fourbar Walker OnShape 零件協同繪圖與組立查驗 請各組依照下列基本尺寸規劃, 以協同方式在 OnShape 環境中完成四連桿四足行走機構, 並分別拍攝協同規劃與實際操作影片, 將影片送到 1) Youtube 2) Vimeo 以及各組的 Fossil Server 基本尺寸規劃 完成圖 (零件連結) 40423222協同產品設計實習W9-Fourbar Walker OnShape 零件協同繪圖與組立查驗 from 40423222 on Vimeo . (四) 分組協同零件展示 window.onload = function(){ var madeleine = new Madeleine({ target: 'target', // target div id data: './../data/Fourbar Walker.stl', // data path path: './../data/madeleine/src/' // path to source directory from current html file }); }; select stl file: or drop stl file","url":"./midterm-collaboration-evaluation.html","tags":"Course","title":"2017/04/19 期中協同查驗與自評"},{"text":"以下為bg7小組組長的內容(20170427,1:19): 心得與自評 心得與自評: 在評分前的這最後一天,將近五個小時的奮鬥,終於將bg7_W1~W8都補上了. 雖然大多時間都是在Ctrl+C and Ctrl+V,但我至少會挑選,選做得好的組員,來Ctrl+C and Ctrl+V. 對於這種 不放棄的精神 ,我認為拿個60分,很合理,","url":"./2017spring-cd-W8.html","tags":"Course","title":"2017/04/12 第八週"},{"text":"以下為bg7小組組長總合出的bg7_W7內容: 利用emd對Fossil倉儲進行管理 ; 用Onshape繪製八連桿 ; 將八連桿匯入V-rep並模擬 ; 影片區 利用emd對Fossil倉儲進行管理: 利用以下指令對fossil倉儲進行管理 fossil clone uri foo.fossil (將遠端的倉儲下載下來) fossil open ./../../foo.fossil (將下載下來的倉儲打開) fossil add . (將改版的倉儲推至暫存區) fossil remote-url off (將自動推送改為手動，這是與git不同之處，fossil會自動推送) fossil push https://user@192.168.X.XX (將暫存區的檔案推至遠端) 用Onshape繪製八連桿: 用參數指令繪製零件 並利用轉動指令及緊固指令將八連桿組立起來 將八連桿匯入V-rep並模擬: 與四連桿相同，只不過這次加入了更多的Dummy，因此在其從屬關係上須特別小心。 影片區: 40423228 (1).零件 20170405 part1 from 40423228 on Vimeo . (2).零件 20170405 part2 from 40423228 on Vimeo . (3).組合 20170405 part3 from 40423228 on Vimeo . (4).組合 20170405 part4 from 40423228 on Vimeo . 40423245 1. 利用fossil對倉儲進行管理練習 40423245機械設計工程系 - 協同產品設計實習課程W7-利用fossil對倉儲進行管理練習 from 40423245 on Vimeo . 2. 利用Onshape繪製八連桿 40423245機械設計工程系 - 協同產品設計實習課程W7-利用Onshape繪製八連桿 from 40423245 on Vimeo . 3. 將八連桿匯入V-rep並使其作動 40423245機械設計工程系 - 協同產品設計實習課程-W7-將八連桿匯入V-rep並使其作動 from 40423245 on Vimeo .","url":"./2017spring-cd-W7.html","tags":"Course","title":"2017/04/05 第七週"},{"text":"以下為bg7小組組長總合出的bg7_W6內容: 用Onshape的變數指令繪製四連桿 ; 將四連桿匯入V-rep模擬 ; 影片區 用Onshape的變數指令繪製四連桿: 在Onshape裡建立一個新文件，並設定好參數設定 接著繪製草圖，在標註尺寸時利用#+參數名稱加入設定好的參數，並將其擠出為零件 接著在組合件裡匯入零件，並利用 指令組立桿子，利用 指令組立軸 零件連結 ： Onshape四連桿機構 將四連桿匯入V-rep模擬: 將組立好的四連桿轉出stl，並匯入V-rep，將各個零件分開，加入旋轉軸，加入馬達，將桿子設為動態物件後，設好從屬關係。 接著新增兩個Dummy 並設定兩個Dummy的關係Dynamics 影片區: 20170329四連桿 from 40423228 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程-W6上課練習 from 40423245 on Vimeo . 2017CD 第六週 from 40423248 on Vimeo .","url":"./2017spring-cd-W6.html","tags":"Course","title":"2017/03/29 第六週"},{"text":"以下為bg7小組組長總合出的bg7_W5內容: 在Fossil主頁上顯示筆記 ; V-rep模擬單連趕 ; 影片區 在Fossil主頁上顯示筆記: 在wiki新增一個與倉儲同名稱的筆記，即可在fossil倉儲主頁上顯示這筆記內容 Note : 要是在Wiki上建立了,多餘的筆記,只要用修改,把內容全Delete,這筆記就會看不見 (但還是會有紀錄) V-rep模擬單連趕: 將上週的單連桿帶入V-rep模擬 接著利用Divide selected shapes將單連桿的零件分開 利用Add/Joint/Revolute新增一個旋轉軸 將旋轉軸的位置跟繪製的軸合併再一起 設置好各零件的從屬關係 接著設定旋轉軸的角速度，並固定單連桿 接著將桿子設為動態物件 影片區: 40423228 20170322 單連桿vrep作動 from 40423228 on Vimeo . 0322 四連桿 part1 from 40423228 on Vimeo . 20170322 四連桿 part2 from 40423228 on Vimeo . 40423245 40423245機械設計工程系 - 協同產品設計實習課程-W5上課練習 from 40423245 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程-W5回家練習 from 40423245 on Vimeo .","url":"./2017spring-cd-W5.html","tags":"Course","title":"2017/03/22 第五週"},{"text":"以下為bg7小組組長總合出的bg7_W4內容: Fossil的組員之新增和權限設定 ; Onshape繪製單連桿機構並轉出stl檔案 ; solvespace繪製單連桿機構並轉出stl檔案 ; 影片區 Fossil的組員之新增和權限設定: Fossil小組倉儲: cdbg7 登入Fossil後,如果你的身分有Setup或是Admin,來到admin/user/add這裡可新增成員跟給定全線 Onshape繪製單連桿機構並轉出stl檔案: 繪製出所需零件 ，底座、軸及單連桿，並將其組立起來 Onshape單連桿機構 solvespace繪製單連桿機構並轉出stl檔案: 繪製出所需零件 ，底座、軸及單連桿，並將其組立起來 影片區: 40423228 0315單連桿-OnShape from 40423228 on Vimeo . 0315單連桿-SolveSpace from 40423228 on Vimeo . 40423245 1. Fossil新增組員以及組員權限設定 Fossil新增組員 2. 在Onshape繪製單連桿機構並轉出stl檔案 Onshape單連桿機構 3. 在solvespace繪製單連桿機構並轉出stl檔案 solvespace單連桿機構 4. 回家練習 回家練習 40423248 2017CD 第四週 from 40423248 on Vimeo .","url":"./2017spring-cd-W4.html","tags":"Course","title":"2017/03/15 第四週"},{"text":"以下為bg7小組組長總合出的bg7_W3內容: mde2a1 ; 用Oshape的四連桿,轉入v-rep開啟 ; 編輯Hyperworks的兩個影片 ; 影片區 mde2a1: 點進wiki裡面的list,再點進2017springcd,就能看到每一週要做的事 用Oshape的四連桿,轉入v-rep開啟: 在Oshape繪製30,50,60的連趕 30的連趕 50的連趕 60的連趕 組裝完成 編輯Hyperworks的兩個影片: 由40423245跟40423248負責編輯 Hyperworks的全部影片 Hyperworks1 Hyperworks2 Hyperworks3 Hyperworks4 Hyperworks 14-1 Hyperworks 14-2 Hyperworks 14-3 Hyperworks 14-4 Hyperworks 14-5 Hyperworks 14-6 14-4 hyperworks 14 4英文字幕 from 40423222 on Vimeo . hyperworks 14 4中文字幕 from 40423222 on Vimeo . hyperworks 14 4中文字幕 from 40423222 on Vimeo . 14-5 hyperworks 14 5英文字幕 from 40423222 on Vimeo . hyperworks 14 5中文字幕 from 40423222 on Vimeo . hyperworks 14 5中英字幕 from 40423222 on Vimeo . 影片區: 40423228 任務三 Onshape 完成與第二點相同尺寸之四連桿機構 from 40423228 on Vimeo . 任務四、五 四連桿軌跡圖 from 40423228 on Vimeo . 40423228機械設計工程系-協同產品設計實習課程-W1 from 40423228 on vimeo . 40423245 任務二影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務二完成 Solvespace 30-50-60 cm 比例的四連桿組立 from 40423245 on Vimeo . 任務三影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務三利用 Onshape 完成四連桿機構, 以 stl 轉出後, 再轉入 V-rep from 40423245 on Vimeo . 任務四、五影片 40423245機械設計工程系 - 協同產品設計實習課程-W3任務四、任務五 from 40423245 on Vimeo . 40423248 2017CD 第三週 from 40423248 on Vimeo .","url":"./2017spring-cd-W3.html","tags":"Course","title":"2017/03/08 第三週"},{"text":"以下為bg7小組組長總合出的bg7_W2內容: 用python程式找出缺課同學 ; 用solvespace繪製並組立四連桿,再轉檔用v-rep開啟 ; 影片區 用python程式找出缺課同學: 可至 班級倉儲內的data下載W2資料夾 裡的cd_w2.py(有填寫座位表的人)和w2b_registered.txt(有修課的人)，接著利用利用程式碼列印出分組名單、座位列表、缺席學生和學生總數 座位程式碼 import os 讀取w2b_cadlab.txt的檔案將其儲存為adata，並設定encoding為utf-8 adata = open(\"w2b_cadlab.txt\", encoding=\"utf-8\").read() 讀取w2b_registered.txt的檔案將其儲存為rdata，並一行一行隔開，並設定encoding為utf-8 rdata = open(\"w2b_registered.txt\", encoding=\"utf-8\").read().splitlines() 列印出adata，以便檢查結果 print(adata) 利用splitlines將adata一行一行隔開並其儲存為alist alist = adata.splitlines() 列印出alist[2]，以便檢查結果 print(alist[2]) 將變數n儲存為0 n = 0 將列從0開始算起 row = 0 將final_list儲存為一個空的數列 final_list = [] 將w2_list儲存為一個空的數列 w2_list = [] 執行一個for迴圈從第二列開始 for stud_num in alist[2:]: #每執行完一次迴圈列數+1 row = row + 1 #執行完迴圈後用\\將其隔開並儲存為blist blist = stud_num.split(\"\\t\") #列印出blist，以便檢查結果 #print(blist) #將行從0開始算起 column = 0 #執行一個for迴圈去取得blist裡的數列 for i in range(len(blist)): #每執行完一次迴圈行數+1 column = column + 1 #假如blist數列裡不是空白 if blist[i] != \"\": #列印出blist[i]，以便檢查結果 #print(blist[i]) #將組序有用_隔開的儲存為clist clist = blist[i].split(\" \") #將組序+ +學號+ +列+行的資料儲 stud_data = clist[0]+\" \"+clist[1]+\" \"+str(row)+\" \"+str(column) #將stud_data結果附加在final_list的資料裡 final_list.append(stud_data) #將clist[1]結果附加在w2_list的資料裡 w2_list.append(clist[1]) #每執行完一次迴圈n+1 n = n +1 根據數列前導字串排序, 目的在建立分組數列 group_list = sorted(final_list) 列印出分組名單 print(\"分組名單:\") 執行一個for迴圈去取得group_list裡的數列 for i in range(len(group_list)): #列印出 group_list[i]的資料 print(group_list[i]) 列印出座位列表 print(\"座位列表:\") 執行一個for迴圈去取得final_list裡的數列 for i in range(len(final_list)):存為stud_data #列印出 final_list[i]的資料 print(final_list[i]) 執行一個for迴圈去取得rdata裡的數列 for i in range(len(rdata)): #假如有在rdata裡但沒有在w2_list裡，目的在找出缺席學生 if rdata[i] not in w2_list: #列印出 rdata[i]的資料，缺席學生 print(\"缺席學生:\", rdata[i]) 列印出學生總數n個 print(\"學生總數:\", n) print(os.environ) 用solvespace繪製並組立四連桿,再轉檔用v-rep開啟: 先在solvespace裡繪製出四連桿結構 再將桿子組立起來(利用點與點的重合、線的共線及點與面的重合，限制桿子的作動。) 最後將四連桿儲存成stl檔`並用Vrep裡的import裡的Mash開啟(開啟時四連桿會重疊到地面，可用object/item shift調整Z軸高度) 影片區: Solvespace 30-50-60 cm 比例的四連桿組立 from 40423228 on Vimeo . 40423245機械設計工程系 - 協同產品設計實習課程-W2 from 40423245 on Vimeo . 2017CD 第二週 from 40423248 on Vimeo .","url":"./2017spring-cd-W2.html","tags":"Course","title":"2017/03/01 第二週"},{"text":"以下為bg7小組組長總合出的bg7_W1內容: 學期的課程大綱 ; 了解如何使用stunnel ; 利用python程式碼控制Vrep ; 影片區 學期的課程大綱: 可至 2017 Spring協同產品設計實習 觀看 了解如何使用stunnel: 在按下start之後,會出現錯誤的圖案,這是因為stunnel資料夾裡的config/styunnel.conf裡的ip與電腦的ip不同 可至cmd打ipconfig/all的指令,找到電腦的ip位置並將其複製、利用Scite編輯貼到styunnel.conf裡 利用python程式碼控制Vrep: 可至 課程倉儲 的data裡下載fourbar_eightbar_solvespace_vrep.7z以及onelink_vrep_remoteapi_pos_vel.7z兩個檔案，解壓縮後會有三個檔案，分別是單連桿、四連桿及八連桿，可試著在solvespace及Vrep裡開啟。 在Vrep裡開啟one_link_robot_remoteAPI.ttt的檔案(ttt是Vrep檔案的副檔名)，在SciTE裡開啟one_link_robot_remoteAPI_joint_target_vel.py的檔案，按下Tool裡的Go即可開始控制單連桿，按Enter會旋轉，按P會暫停 影片區: stunnel設定 from 40423228 on Vimeo . 40423245機械設計工程系-協同產品設計實習課程-W1 from 40423245 on Vimeo . 2017CD 第一週 from 40423248 on Vimeo .","url":"./2017spring-cd-W1.html","tags":"Course","title":"2017/02/22 第一週"}]};